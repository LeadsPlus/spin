#!/usr/bin/env ruby

require 'set'
$LOAD_PATH << 'test'
ENV['RAILS_ENV'] = 'test'

def main
  # pipe for communication between watcher proc and master proc
  rd, wr = IO.pipe

  # pass the write end of the pipe to the watcher proc
  @watcher_pid = fork { start_watcher(wr) }

  # the master doesn't need to write to the pipe so it closes that end
  wr.close

  # load rails
  require File.expand_path 'config/application'
  puts 'loaded rails...'

  sizeof_int = [42].pack('I').size

  @has_forked = false
  @file_queue = Set.new

  loop do

    while !IO.select([rd], nil, nil, 1)
      if !@has_forked && !@file_queue.empty?
        run_tests
      end
    end

    data = rd.read(sizeof_int)
    size = data.unpack('I').first
    filepath = rd.read size

    @file_queue << filepath

    if !@has_forked
      run_tests
    end
  end
end

def run_tests
  tests_to_run = @file_queue.to_a
  puts "running tests: #{tests_to_run}"

  @test_start = Time.now
  fork { 
    tests_to_run.each do |path|
      require path
    end
  }

  @file_queue.clear
  @has_forked = true
end

trap(:CHLD) {
  while pid = Process.wait(-1, Process::WNOHANG) do
    # abort if the watcher proc dies unexpectedly
    if pid == @watcher_pid 
      abort("Watcher process exited unexpectedly")
    else
      @has_forked = false
      puts
      puts "Time taken for tests: #{Time.now - @test_start}s"
    end
  end
}

def start_watcher(wr)
  require 'rubygems'
  require 'fssm'
  FSSM.monitor do
    path 'test/' do
      update { |base, relative|
        full_path = [base, relative].join('/')
        wr.write([full_path.size].pack('I')) + wr.write(full_path)
      }
    end
  end
end

exit main

